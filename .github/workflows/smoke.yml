name: CI Smoke - Webhook

on:
  pull_request:
  push:
    branches: [ main ]

jobs:
  smoke:
    name: Smoke webhook on Windows
    runs-on: windows-latest

    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      ASPNETCORE_ENVIRONMENT: Development
      SWISH_WEBHOOK_SECRET: dev_secret
      SWISH_DEBUG: "1"
      FIXED_URL: "http://localhost:5055"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore & build
        shell: pwsh
        run: |
          dotnet restore
          dotnet build --configuration Debug --nologo

      - name: Start sample server (background process)
        id: start_sample
        shell: pwsh
        run: |
          $proj = ".\samples\SwishSample.Web\SwishSample.Web.csproj"
          $log  = "$env:RUNNER_TEMP\sample-log.txt"

          # Start as a separate process and capture the PID
          $psi = New-Object System.Diagnostics.ProcessStartInfo
          $psi.FileName  = "dotnet"
          $psi.Arguments = "run --project `"$proj`" --urls `"$env:FIXED_URL`""
          $psi.RedirectStandardOutput = $true
          $psi.RedirectStandardError  = $true
          $psi.UseShellExecute = $false
          $proc = New-Object System.Diagnostics.Process
          $proc.StartInfo = $psi
          $null = $proc.Start()

          # Stream logs to file asynchronously
          $out = $proc.StandardOutput.ReadToEndAsync()
          $err = $proc.StandardError.ReadToEndAsync() | Out-Null
          Start-Job -Name LogDrain -ScriptBlock {
            param($task, $path)
            $content = $task.GetAwaiter().GetResult()
            [IO.File]::WriteAllText($path, $content)
          } -ArgumentList $out, $log | Out-Null

          # Save output to GITHUB_OUTPUT (NOTE: not the $PID variable)
          "SAMPLE_PID=$($proc.Id)"    >> $env:GITHUB_OUTPUT
          "LOG=$log"                  >> $env:GITHUB_OUTPUT
          "URL=$env:FIXED_URL"        >> $env:GITHUB_OUTPUT

          # Wait for /health to respond (timeout ~45s)
          $ok = $false
          for ($i=0; $i -lt 45; $i++) {
            try {
              $resp = Invoke-RestMethod -Uri "$($env:FIXED_URL)/health" -TimeoutSec 2 -ErrorAction Stop
              if ($resp -eq "ok") { $ok = $true; break }
            } catch { Start-Sleep -Seconds 1 }
          }
          if (-not $ok) {
            Write-Host "Sample did not become healthy. Current log:"
            if (Test-Path $log) { Get-Content $log -Raw | Write-Host }
            throw "Sample not healthy"
          }
          Write-Host "Sample is healthy at $env:FIXED_URL"

      - name: Run smoke script (OK + replay -> 401)
        shell: pwsh
        run: |
          # Bypass execution policy to safely run our script
          Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force
          .\scripts\smoke-webhook.ps1 -Url "${{ steps.start_sample.outputs.URL }}/webhook/swish" -Secret "dev_secret" -Replay

      - name: Print sample log on failure
        if: failure()
        shell: pwsh
        run: |
          $log = "${{ steps.start_sample.outputs.LOG }}"
          if (Test-Path $log) {
            Write-Host "---- SAMPLE LOG BEGIN ----"
            Get-Content $log -Raw | Write-Host
            Write-Host "---- SAMPLE LOG END ----"
          } else {
            Write-Host "No sample log found."
          }

      - name: Stop sample server
        if: always()
        shell: pwsh
        run: |
          $samplePid = "${{ steps.start_sample.outputs.SAMPLE_PID }}"
          if ($samplePid) {
            try { Stop-Process -Id [int]$samplePid -Force -ErrorAction SilentlyContinue } catch {}
          }
          $job = Get-Job -Name LogDrain -ErrorAction SilentlyContinue
          if ($job) {
            try { Receive-Job $job -Wait -AutoRemoveJob | Out-Null } catch {}
          }
